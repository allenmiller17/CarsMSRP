---
title: "6372 Auto Project"
author: "Justin Ehly"
date: "1/18/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries}
### Libraries ###
library(car)
library(magrittr)
library(tibble)
library(naniar)
library(VIM)
library(FactoMineR)
library(purrr)
library(gdata)
library(glmnet)
library(leaps)
library(ISLR)
library(caret)
library(tidyverse)
library(stringr)
library(ggplot2)
library(scales)
library(dplyr)
```

```{r get-data}
### Download Data and Clean ###

# teammates that fork this code chunk, be sure to set
# your working directory to the DataSet folder in your your github folder
#setwd("C:/Users/justi/Documents/GitHub/6372-Auto-Pricing-Project/DataSet")
setwd(choose.dir()) #this only works on a windows machine

auto_data <- read.csv("data1.csv")
view(auto_data)

summary(auto_data)
str(auto_data)
names(auto_data)
autos <- auto_data
```

```{r clean data}
#############################

###    Clean the dataset  ###

#############################

autos <- rename(autos, mpg.highway = highway.MPG, mpg.city = city.mpg)
# replace all chr with factors
autos[sapply(autos,is.character)] <- lapply(autos[sapply(autos,is.character)], as.factor)
autos$Year <- as.factor(autos$Year) # make Year into a factor
autos$Number.of.Doors <- as.factor(autos$Number.of.Doors) # change to factor

str(autos)
#view(autos)


### Audi A6 sure does have an awesome mpg.highway - should be 34 not 354 ###
autos$mpg.highway[1120] <- 34

# create an average mpg column
autos$avgMPG <- (autos$mpg.city+autos$mpg.highway) / 2
names(autos)
autos <- autos[,-c(13,14)]
str(autos)

##### Look for any missing values including NA, variants of NA and 'UNKNOWN's in the data set ####

missing <- sapply(autos, function(x) sum(sum(x %in% common_na_strings), 
                                        sum(x %in% common_na_numbers),
                                        sum(is.na(x)), 
                                        sum(x %in% 'UNKNOWN')))
missing 

### Plot missing data ### 
missing <- data.frame(as.list(missing)) # convert names int vector to dataframe
missing <- as.data.frame(t(as.matrix(missing))) # transpose the matrix
missing <- rename(missing, 'MissingValues'='V1')
missing$Variables <- rownames(missing)
missing <- missing[,c(2,1)]
rownames(missing) <- 1:nrow(missing)
missing <- missing[order(missing$MissingValues, decreasing = TRUE),]
missing

missing %>% ggplot(aes(y=reorder(Variables,MissingValues), 
                    x=MissingValues, fill=Variables)) + 
  geom_col(show.legend = FALSE) + 
  labs (title ="Missing Values by Variable",
        x = "No. Missing Values",
        y = "Varaiables") +
  geom_text(aes(label=comma(MissingValues, accuracy = 1)), nudge_x = 100, size=3) +
  scale_x_continuous(labels=comma) +
  theme_bw()

### Clean up data ###

#Fiat 500e - electric so no cylinders
autos$Engine.HP[c(540:542)] <- 111 

#2017 Continental
autos[c(2906:2909),]
autos$Engine.HP[c(2906:2909)] <- 400 

#2017 Escape
autos[c(4204:4207),]
autos$Engine.HP[c(4204:4207)] <- 179 

#2013-2014 Fit EV
autos[c(4706,4707),]
autos$Engine.HP[c(4706,4707)] <- 123

#2015 Ford Focus EV 143hp
autos[c(4786,4790,4799),]
autos$Engine.HP[c(4786,4790,4799)] <- 143

#2005 Ford Freestar only vans above $29k have 201 HP
autos[c(4915:4928),] %>% select(Engine.HP,avgMPG, MSRP) %>% arrange(logMSRP)
autos[c(4915:4928),] %>% select(Engine.HP,avgMPG, MSRP) %>% arrange(avgMPG)
autos$Engine.HP[c(4915:4918)] <- 193
autos$Engine.HP[c(4919:4920)] <- 201

# 2014 Mitsubishi i-MiEV
autos$Engine.HP[5779] <- 66

# 2015-2016 Kia Soul EV
autos$Engine.HP[c(9851:9855)] <- 109

#2013-2014 Toyota Rav4 EV
autos$Engine.HP[c(8375:8376)] <- 154

#Telsa Model S missing values
autos %>% filter(Make == "Tesla")

tesla <- read.csv("tesla.csv")
#view(tesla)

# mass replace tesla missing values since they were mostly all independent
for(i in 6922:6939){autos$Engine.HP[i] <- tesla$Engine.HP[i-(6921)]}
for(i in 6922:6939){autos$Number.of.Doors[i] <- tesla$Number.of.Doors[i-(6921)]}
#view(autos)

# 2017 Lincoln MKZ - all FWD have 240hp
autos$Engine.HP[c(6909,6911,6917,6919)] <- 240

# 2015 Mercedes M-Class Diesel
autos$Engine.HP[6579] <- 200

#2014-2016 Nissan Leaf - all 107 hp
autos$Engine.HP[c(6386:6395)] <- 107

#### Work on missing cylinders 
missingCyl <- which (is.na(autos$Engine.Cylinders))
#write.csv(autos[missingCyl,],"MissingCyl.csv")
#view(autos[missingCyl,])
#change electric cars to 'e' for cylinders since they don't have any
autos$Engine.Cylinders <- ifelse(autos$Engine.Fuel.Type == 'electric','E',autos$Engine.Cylinders)
#change the mazda RX cars to 'R' for rotary engine since they don't have cylinders
autos$Engine.Cylinders[c(8696:8715)] <- 'R'

# any remaining missing values?
sapply(autos, function(x) sum(sum(x %in% common_na_strings), 
                                        sum(x %in% common_na_numbers),
                                        sum(is.na(x)), 
                                        sum(x %in% 'UNKNOWN')))

# the software seems to think there is 1 value missing for number.of.doors
autos[which(is.na(autos$Number.of.Doors)),]
# 2- door ferrari ff
autos$Number.of.Doors[which(is.na(autos$Number.of.Doors))] <-2

# Engine.Fuel.Type - suzuki is missing
autos$Engine.Fuel.Type[c(11322:11324)] <- 'regular unleaded'

# All that is left now is to either predict or impute the Market.Category - 
# rather, let's follow the path of the directions and just create and "exotic" attribute
exotic <- c('Ferrari','Alfa Romeo','McLaren', 'Maybach', 'Porsche', 
            'Bentley', 'Lamborghini', 'Spyker', 'Rolls-Royce', 'Maserati',
            'Aston Martin', 'Lotus', 'Bugatti')
for(i in 1:length(autos$Make)){
  ifelse(autos$Make[i] %in% exotic,autos$Exotic[i] <- 'Exotic', autos$Exotic[i] <- 'Not Exotic')
}
# Actually after some further evaluation, I feel setting the exotic car price ta at $100k is a better fit for analysis also, let's remove the Bugatti, those literally sale <100 annually

autos<-autos[-c(11363:11365),]
unique(autos$Make)

autos$Exotic <- as.character(autos$Exotic)
autos$Exotic <- case_when(
  autos$MSRP > 100000 ~ "Exotic",
  TRUE ~ autos$Exotic
)

#view(autos %>% filter(autos$MSRP > 100000) )

autos$Exotic <- as.factor(autos$Exotic)
str(autos)
autos$Market.Category <- NULL #remove this unused column, it's overly complex

autos$Engine.HP <- as.integer(autos$Engine.HP)

#2015 Impala duel-fuel - since only a 30hp difference, might as well use the higher hp

autos[c(5826,5831, 5832, 5834, 5840, 5841),]
autos$Engine.HP[c(5826,5831,5832,5834,5840, 5841)] <- 260

str(autos)
# replace all chr with factors
autos[sapply(autos,is.character)] <- lapply(autos[sapply(autos,is.character)], as.factor)
autos$Year <- as.factor(autos$Year) # make Year into a factor
autos$Number.of.Doors <- as.factor(autos$Number.of.Doors) # change to factor
autos[sapply(autos,is.integer)] <- lapply(autos[sapply(autos,is.integer)], as.numeric)


# Transmission Types has 19 missing values
autos$Transmission.Type[c(1290:1291)] <- "AUTOMATIC" #Oldsmobile Achieva
autos$Transmission.Type[c(4692:4694)] <- "AUTOMATIC" #Pontiac Firebird with 15/23 MPG and V8
autos$Transmission.Type[c(6159,6161,6166,6175)] <- "AUTOMATIC" #1999/2000 GMC Jimmy
autos$Transmission.Type[c(6367,6369)] <- "AUTOMATIC" #1993 Chrysler LeBaron
autos$Transmission.Type[c(8043,8044,8047:8050,8052,8054)] <- "AUTOMATIC" #1991 Dodge Ram 150

# recheck for missing values
sapply(autos, function(x) sum(sum(x %in% common_na_strings), 
                                        sum(x %in% common_na_numbers),
                                        sum(is.na(x)), 
                                        sum(x %in% 'UNKNOWN')))


# export the final cleansed data set for reporting
write.csv(capture.output(str(autos)), "cleanData.csv")


```

```{r objective 1 EDA}
####################

### EDA  ###########

####################


summary(autos) #summary of main autos df
# we also know from a first pass that we need a transformed MSRP
autos$logMSRP <- log(autos$MSRP)

# rearrrange autos df
autos <- autos[,c(16,1:12,14,15)]
str(autos)

### What's going on with the Popularity variable? ###

### Make ###
t(aggregate(Popularity~Make,data=auto_data,min)) #appears each make has a specific popularity
autos %>% dplyr::group_by(Make) %>% 
  summarise(mean = mean(Popularity), range=range(Popularity)) %>%
  ggplot(aes(x=Make, y=mean, fill=Make)) +
  geom_col(show.legend = FALSE) +
  labs(title = "Average Popularity Score by Make",
       y = "Averge Popularity", 
       x = "Car Make") + 
  scale_y_continuous(label=comma) +
  coord_flip() +
  theme_bw()

#Seems each make just has one popularity score
autos %>% dplyr::group_by(Make) %>% 
       summarize(min=min(Popularity),
                 mean=mean(Popularity), 
                 max=max(Popularity))

#joeCool <- as.matrix(auto_data %>% dplyr::group_by(Make,Model) %>% 
       #summarize(min=min(Popularity),
        #         mean=mean(Popularity), 
         #        max=max(Popularity))
#view(joeCool)
#auto_data %>% count(Popularity, Make)
# Confirmed, Popularity is directly tied to Make, they are interchangeable and thus we only need to use one of them


##### Relationship between Make and MSRP ###

autos %>% filter(Exotic == "Not Exotic") %>%
  ggplot(aes(x=reorder(Make, desc(Make)), y=logMSRP, fill=Make)) +
  geom_boxplot(aes(group = Make), show.legend = FALSE) +
  labs(title = "Non-Exotic Make by logMSRP",
       y = "logMSRP", 
       x = "Car Make") +
  scale_y_continuous(label=dollar_format()) +
  coord_flip() +
  theme_bw()

autos %>% filter(Exotic == "Exotic") %>%
  ggplot(aes(x=reorder(Make, desc(Make)), y=logMSRP, fill=Make)) +
  geom_boxplot(aes(group = Make), show.legend = FALSE) +
  labs(title = "Exotic Make by logMSRP",
       y = "logMSRP", 
       x = "Car Make") +
  scale_y_continuous(label=dollar_format()) +
  coord_flip() +
  theme_bw()

### Relationship between Cylinders and Horsepower ##
autos %>% #filter(Exotic == "Not Exotic") %>%
  ggplot(aes(x=reorder(Engine.Cylinders, Engine.HP), 
             y=Engine.HP, fill=Engine.Cylinders)) +
  geom_boxplot(aes(group = Engine.Cylinders), show.legend = FALSE) +
  labs(title = "Engine Cylinders vs Horsepower",
       y = "Horsepower", 
       x = "Cylinders/ Engine Type",
       caption = "R: RotaryEengine; E: Electric Engine") +
  scale_y_continuous(label=comma) +
  coord_flip() +
  theme_bw()

# look at the matrix plots of explanatory variables compared to logMSRP
# keep in mind we are reduced to just 2 - Engine.HP and avgMPG
pairs(autos[,c(1,6,14)]) #logMSRP ~ HP + Popularity, avgMPG

# There looks to be some relatioinships there, but before logging, we should run some models and check the residuals.


 


```

```{r clean up the categorical variables}
########################################

### Clean up categorical variables #####

########################################


names(autos)
# remove popularity
autos <- autos[,c(1:12,14:15)]
names(autos)

block_saver <- autos # in case I accidentally mess up the dataframe, I can restart here without having to start all the way from the beginning


autos1 <- autos[,-c(2:4,10)] #Make, model, year, doors
names(autos1)
str(autos1)
mod.fit <- aov(logMSRP~., data=autos1)
summary(mod.fit)

# Everything looks ok here, let's look at an lm to test within the categorical variables

test.lm <- lm(logMSRP~., data=autos1)
summary(test.lm)



##################

### Fuel Types ###

##################
# test for differences in fuel types related to logMSRP
test_lm <- lm(logMSRP~Engine.Fuel.Type, data=autos1)
summary(test_lm)

# Testing for unleaded differences
test_lm <- autos1 %>% filter(grepl("unleaded",Engine.Fuel.Type)) %>%
  lm(logMSRP~Engine.Fuel.Type, data=.)
summary(test_lm)


autos1$new.fuel <- as.factor(autos1$Engine.Fuel.Type)
autos1$new.fuel <- as.factor(autos1$new.fuel)

autos1$new.fuel <- str_replace_all(autos1$new.fuel, "premium unleaded \\(recommended\\)", "regular unleaded")
unique(autos1$new.fuel)
test_lm <- lm(logMSRP~new.fuel, data=autos1)
summary(test_lm)

autos1$new.fuel <- str_replace_all(autos1$new.fuel, "flex-fuel \\(premium unleaded recommended\\/E85\\)", "flex-fuel (unleaded/E85)")
test_lm <- lm(logMSRP~new.fuel, data=autos1)
summary(test_lm)

autos1$new.fuel <- str_replace_all(autos1$new.fuel, "flex-fuel \\(unleaded\\/E85\\)", "flex-fuel")
autos1$new.fuel <- str_replace_all(autos1$new.fuel, "flex-fuel \\(unleaded\\/natural gas\\)", "flex-fuel")
test_lm <- lm(logMSRP~new.fuel, data=autos1)
summary(test_lm)

autos1$new.fuel <- case_when(
  autos1$new.fuel == "natural gas" ~ "alternative",
  autos1$new.fuel == "flex-fuel" ~ "alternative",
  autos1$new.fuel == "diesel" ~ "alternative",
  autos1$new.fuel == "electric" ~ "alternative",
  TRUE~autos1$new.fuel)

autos1$new.fuel <- as.factor(autos1$new.fuel)
levels(autos1$new.fuel)

autos1$Engine.Fuel.Type <- autos1$new.fuel
levels(autos1$Engine.Fuel.Type)
str(autos1)
names(autos1)
new.fuel.index <- grep("new.fuel", colnames(autos1))
# remove new.fuel
autos1 <- autos1[,-new.fuel.index]


###### New LM test ##########

test_lm <- lm(logMSRP~., data=autos1)
summary(test_lm)
names(autos1)

# Engine.HP looks good pvalue = < 2e-16
# Transmission needs some cleaning up

#########################

### Transmission  #######

#########################

# Transmission Direct Drive appears insig pvalue =0.6314
levels(autos1$Transmission.Type)

autos1$Transmission.Type <- str_replace_all(autos1$Transmission.Type, "AUTOMATED_MANUAL", "n")
autos1$Transmission.Type <- str_replace_all(autos1$Transmission.Type, "DIRECT_DRIVE", "n")
autos1$Transmission.Type <- str_replace_all(autos1$Transmission.Type, "n", "AUTO-MANUAL-OR-DIRECT-DRIVE")

autos1$Transmission.Type <- as.factor(autos1$Transmission.Type)

### new LM test ###

test_lm <- lm(logMSRP~., data=autos1)
summary(test_lm)

# Transmisson.Type looks good now
# Wheels Driven needs some attention

############################

### Driven Wheels ##########

############################

# Driven Wheels
autos1$Driven_Wheels <- str_replace_all(autos1$Driven_Wheels, "four wheel drive", "zzz")
autos1$Driven_Wheels <- str_replace_all(autos1$Driven_Wheels, "all wheel drive", "zzz")
autos1$Driven_Wheels <- str_replace_all(autos1$Driven_Wheels, "front wheel drive", "zzz")
autos1$Driven_Wheels <- str_replace_all(autos1$Driven_Wheels, "zzz", "all or 4 wheel drive")
autos1$Driven_Wheels <- as.factor(autos1$Driven_Wheels)
levels(autos1$Driven_Wheels)

test_lm <- lm(logMSRP~., data=autos1)
summary(test_lm)

# Vehicle size looks ok too
# Vehicle style may need some attention


# convertible suv's seem to be insignificant, let's just check to see what we can marry them to

autos %>% filter(Vehicle.Style == "Convertible SUV") %>% distinct(Make, Model, Year) %>% arrange(Make)
# chevy, landrovers, nissans, suzukis are 2-door

autos1$Vehicle.Style <- as.character(autos1$Vehicle.Style)
autos1$Vehicle.Style <- case_when(
  autos1$Vehicle.Style == "2dr SUV" ~ "SUV",
  autos1$Vehicle.Style == "4dr SUV" ~ "SUV",
  autos1$Vehicle.Style == "Convertible SUV" ~ "SUV",
  autos1$Vehicle.Style == "4dr Hatchback" ~ "Sedan",
  autos1$Vehicle.Style == "2dr Hatchback" ~ "Sedan",
  autos1$Vehicle.Style == "Wagon" ~ "Sedan",
  autos1$Vehicle.Style == "Extended Cab Pickup" ~ "Pickup",
  autos1$Vehicle.Style == "Regular Cab Pickup" ~ "Pickup",
  autos1$Vehicle.Style == "Crew Cab Pickup" ~ "Pickup",
  autos1$Vehicle.Style == "Cargo Minivan" ~ "Cargo",
  autos1$Vehicle.Style == "Cargo Van" ~ "Cargo",
  autos1$Vehicle.Style == "Passenger Van" ~ "Passenger Van",
  autos1$Vehicle.Style == "Passenger Minivan" ~ "Passenger Van",
  TRUE ~ autos1$Vehicle.Style
)

autos1$Vehicle.Style <- as.factor(autos1$Vehicle.Style)
levels(autos1$Vehicle.Style)

### Lm test
test_lm <- lm(logMSRP~., data=autos1)
summary(test_lm)

# looks good now


vif(test_lm) # all vif's look good around 1

vif(test_lm)[,3]^2
## (avgMPG may be an issue, but let's hang tight with that)

autos1$Make <- autos$Make
autos1$Model <- autos$Model
autos1$Year <- autos$Year
autos <- autos1
str(autos)

str(autos)
summary(autos)


```


```{r create 3 data sets}
##############################

#### Create 3 Data Sets  #####

##############################

# Removing the Model variable prior to splitting the sets
# Initial pass with the models included was way over fit with adjr=97%, let's remove model
autos <- autos[,-12]
autos <- autos[,-11]
names(autos)

set.seed(123)
spec = c(train = .8, test = .1, validate = .1) #set the split percentages 80/10/10

ind = sample(cut(
  seq(nrow(autos)), 
  nrow(autos)*cumsum(c(0,spec)),
  labels = names(spec)
))

autosplits = split(autos, ind)

# check results
sapply(autosplits, nrow)/nrow(autos)
#     train       test   validate 
# 0.79998321 0.09996643 0.10005036 

# assign simple common names to each dataset 
train <- autosplits$train
test <- autosplits$test
validate <- autosplits$validate

str(train)
str(test)
str(validate)


```

Objective 1: Display the ability to build regression models using the skills and discussions from Unit 1 and 2 with the purpose of identifying key relationships and interpreting those relationships. A key question of interest that must be addressed in this analysis is the importance of the "Popularity" variable. While the details of this variable are vague, it was created from social media, and the "higher ups" are curious how much general popularity can play a role in the retail price of a vehicle.


### FORWARD MODEL ###


```{r forward}

# I recommend restarting R at this point because the plots for some reason aren't showing labels

reg.fwd <- regsubsets(logMSRP ~ .,data=train, method="forward", nvmax=100)

summary(reg.fwd)$adjr2

summary(reg.fwd)$rss

summary(reg.fwd)$bic

par(mfrow=c(1,3))
  bics <- summary(reg.fwd)$bic
  graphics::plot(1:(reg.fwd$nvmax-1), bics, type="l", 
                 ylab="BIC", xlab="# of predictors")
  index <- which(bics==min(bics))
  points(index, bics[index], col="red",pch=10)
  
  adjr2 <- summary(reg.fwd)$adjr2
  graphics::plot(1:(reg.fwd$nvmax-1), adjr2, type="l", 
                 ylab="Adj R-squared", 
                 xlab="# of     predictors")
  
  index<-which(adjr2==max(adjr2))
  points(index,adjr2[index],col="red",pch=10)
  
  rss<-summary(reg.fwd)$rss
  graphics::plot(1:(reg.fwd$nvmax-1),rss,type="l",
                 ylab="train RSS",
                 xlab="# of predictors")
  index<-which(rss==min(rss))
  points(index,rss[index],col="red",pch=10)

  
  

###########################
  
### Test Set Prediction ###
  
###########################
  
#Really handy predict function
predict.regsubsets <- function (object , newdata ,id ,...)
  {
  form=as.formula (object$call [[2]])
  mat=model.matrix(form, newdata)
  coefi=coef(object, id=id)
  xvars=names(coefi)
  mat[,xvars]%*%coefi
  }


testASE <- c()
#note my index is to 73 since that is where the predictions from the forward selector stopped
for (i in 1:(reg.fwd$nvmax-1)){
  predictions <- predict.regsubsets(object=reg.fwd, newdata=test, id=i) 
  testASE[i]  <- mean((test$logMSRP - predictions)^2)
}
par(mfrow=c(1,1))
plot(1:(reg.fwd$nvmax-1),testASE,type="l", xlab="# of predictors", ylab="test vs train ASE")
index <- which(testASE == min(testASE))
points(index, testASE[index], col="red", pch=10)
rss <- summary(reg.fwd)$rss
lines(1:(reg.fwd$nvmax-1),rss/11914,lty=3,col="blue")  #Dividing by 11914 since ASE=RSS/sample size

#########################

### Testing the Fit ###

#########################

reg.final <- regsubsets(logMSRP~., data=autos, method="forward", nvmax=27)
coef(reg.final,3)

final.fwd.mod <- lm(logMSRP~Engine.HP + Engine.Cylinders + Exotic, data=autos)
summary(final.fwd.mod)

par(mfrow=c(1,1))
plot(final.fwd.mod$fitted.values,autos$logMSRP,
     xlab="Predicted",
     ylab="logMSRP",
     xlim=c(0,207000),
     ylim=c(0,207000),
     col = "blue")
lines(c(0,207000), c(0,207000), col="red")

head(predict(final.fwd.mod, autos, interval="predict"))

#########################
  
  ### Model Assumptions ###
  
  #########################
  
  par(mfrow=c(2,2))
  plot(final.fwd.mod)
  

```

### ##############################


### BACKWARD MODEL ###

### #############################


```{r backward}
########################

###  Backward Model  ###

########################

reg.bwd <- regsubsets(logMSRP ~ .,data=train, method="backward", nvmax=100)

summary(reg.bwd)$adjr2

summary(reg.bwd)$rss

summary(reg.bwd)$bic

par(mfrow=c(1,3))
  bics <- summary(reg.bwd)$bic
  graphics::plot(1:(reg.bwd$nvmax-1), bics, type="l", 
                 ylab="BIC", xlab="# of predictors")
  index <- which(bics==min(bics))
  points(index, bics[index], col="red",pch=10)
  
  adjr2 <- summary(reg.bwd)$adjr2
  graphics::plot(1:(reg.bwd$nvmax-1), adjr2, type="l", 
                 ylab="Adj R-squared", 
                 xlab="# of     predictors")
  
  index<-which(adjr2==max(adjr2))
  points(index,adjr2[index],col="red",pch=10)
  
  rss<-summary(reg.bwd)$rss
  graphics::plot(1:(reg.bwd$nvmax-1),rss,type="l",
                 ylab="train RSS",
                 xlab="# of predictors")
  index<-which(rss==min(rss))
  points(index,rss[index],col="red",pch=10)

  
  

###########################
  
### Test Set Prediction ###
  
###########################
  
#Really handy predict function
predict.regsubsets <- function (object , newdata ,id ,...)
  {
  form=as.formula (object$call [[2]])
  mat=model.matrix(form, newdata)
  coefi=coef(object, id=id)
  xvars=names(coefi)
  mat[,xvars]%*%coefi
  }


testASE <- c()
#note my index is to 73 since that is where the predictions from the forward selector stopped
for (i in 1:(reg.bwd$nvmax-1)){
  predictions <- predict.regsubsets(object=reg.bwd, newdata=test, id=i) 
  testASE[i]  <- mean((test$logMSRP - predictions)^2)
}
par(mfrow=c(1,1))
plot(1:(reg.bwd$nvmax-1),testASE,type="l", xlab="# of predictors", ylab="test vs train ASE")
index <- which(testASE == min(testASE))
points(index, testASE[index], col="red", pch=10)
rss <- summary(reg.bwd)$rss
lines(1:(reg.bwd$nvmax-1),rss/11914,lty=3,col="blue")  #Dividing by 11914 since ASE=RSS/sample size

#########################

### Testing the Fit ###

#########################

reg.final <- regsubsets(logMSRP~., data=autos, method="backward", nvmax=27)
coef(reg.final,3)

final.bwd.mod <- lm(logMSRP~Engine.HP + Engine.Cylinders + Exotic, data=autos)
summary(final.bwd.mod)

par(mfrow=c(1,1))
plot(final.bwd.mod$fitted.values,autos$logMSRP,
     xlab="Predicted",
     ylab="logMSRP",
     xlim=c(0,207000),
     ylim=c(0,207000),
     col = "blue")
lines(c(0,207000), c(0,207000), col="red")

head(predict(final.bwd.mod, autos, interval="predict"))

#########################
  
  ### Model Assumptions ###
  
  #########################
  
  par(mfrow=c(2,2))
  plot(final.bwd.mod)
 

```

### #####################

### STEPWISE MODEL

### #####################


```{r stepwise}
########################

###  STEPWISE Model  ###

########################

reg.step <- regsubsets(logMSRP ~ .,data=train, method="seqrep", nvmax=100)

summary(reg.step)$adjr2

summary(reg.step)$rss

summary(reg.step)$bic

par(mfrow=c(1,3))
  bics <- summary(reg.step)$bic
  graphics::plot(1:(reg.step$nvmax-1), bics, type="l", 
                 ylab="BIC", xlab="# of predictors")
  index <- which(bics==min(bics))
  points(index, bics[index], col="red",pch=10)
  
  adjr2 <- summary(reg.step)$adjr2
  graphics::plot(1:(reg.step$nvmax-1), adjr2, type="l", 
                 ylab="Adj R-squared", 
                 xlab="# of     predictors")
  
  index<-which(adjr2==max(adjr2))
  points(index,adjr2[index],col="red",pch=10)
  
  rss<-summary(reg.step)$rss
  graphics::plot(1:(reg.step$nvmax-1),rss,type="l",
                 ylab="train RSS",
                 xlab="# of predictors")
  index<-which(rss==min(rss))
  points(index,rss[index],col="red",pch=10)

  
  

###########################
  
### Test Set Prediction ###
  
###########################
  
#Really handy predict function
predict.regsubsets <- function (object , newdata ,id ,...)
  {
  form=as.formula (object$call [[2]])
  mat=model.matrix(form, newdata)
  coefi=coef(object, id=id)
  xvars=names(coefi)
  mat[,xvars]%*%coefi
  }


testASE <- c()
#note my index is to 73 since that is where the predictions from the forward selector stopped
for (i in 1:(reg.step$nvmax-1)){
  predictions <- predict.regsubsets(object=reg.step, newdata=test, id=i) 
  testASE[i]  <- mean((test$logMSRP - predictions)^2)
}
par(mfrow=c(1,1))
plot(1:(reg.step$nvmax-1),testASE,type="l", xlab="# of predictors", ylab="test vs train ASE")
index <- which(testASE == min(testASE))
points(index, testASE[index], col="red", pch=10)
rss <- summary(reg.step)$rss
lines(1:(reg.step$nvmax-1),rss/11914,lty=3,col="blue")  #Dividing by 11914 since ASE=RSS/sample size

#########################

### Testing the Fit ###

#########################

reg.final <- regsubsets(logMSRP~., data=autos, method="seqrep", nvmax=27)
coef(reg.final,3)

final.step.mod <- lm(logMSRP~Engine.HP + Engine.Cylinders + Exotic, data=autos)
summary(final.step.mod)

par(mfrow=c(1,1))
plot(final.step.mod$fitted.values,autos$logMSRP,
     xlab="Predicted",
     ylab="logMSRP",
     xlim=c(0,207000),
     ylim=c(0,207000),
     col = "blue")
lines(c(0,207000), c(0,207000), col="red")

head(predict(final.step.mod, autos, interval="predict"))

#########################
  
  ### Model Assumptions ###
  
  #########################
  
  par(mfrow=c(2,2))
  plot(final.step.mod)
 



```

### ###################

### LASSO MODEL ###

### ###################

```{r LASSO model}

# formatting data for GLM net
x = model.matrix(logMSRP~.,train)[,-1]
y = train$logMSRP

xtest <- model.matrix(logMSRP~.,test)[,-1]
ytest <- test$logMSRP

grid <- 10^seq(10,-2, length = 100)
lasso.mod <- glmnet(x, y, alpha=1, lambda = grid)

cv.out <- cv.glmnet(x, y, alpha=1) # alpha = 1 performs LASSO

bestlambda <- cv.out$lambda.min #Optimal penalty parameter. We can also make this call visually

lasso.pred <- predict(lasso.mod, s= bestlambda, newx=xtest)

testMSE_LASSO <- mean((ytest-lasso.pred)^2)
testMSE_LASSO

coef(lasso.mod, s=bestlambda)

### Plot LASSO results ###
par(mfrow=c(2,2))
plot(lasso.mod)
plot(lasso.mod,
     xvar = "lambda")
plot(cv.out)

```

### #######################

### Boruta Method ###

### #######################

```{r boruta random forest wrapper}
library(Boruta)

boruta_logMSRP <- Boruta(logMSRP~., data=autos, doTrace=2) # Boruta search

boruta_siglogMSRP <- names(boruta_logMSRP$finalDecision[boruta_logMSRP$finalDecision %in% c("Confirmed", "Tentative")]) #collect Confirmed and Tentative variables

print(boruta_siglogMSRP) #view sig var

par(mfrow=c(1,1))
plot(boruta_logMSRP, cex.axis=.7, las=2, xlab="", 
     main="Variable Importance to logMSRP (Boruta Method)") #plot results


```

